simulation:
  AutowareUniverse:
    ros__parameters:
      /localization/kinematic_state:
        version: 20240605 # architecture_type suffix (mandatory)
        seed: 0 # If 0 is specified, a random seed value will be generated for each run.
        nav_msgs::msg::Odometry:
          pose:
            pose:
              position:
                # The data members of geometry_msgs::msg::Pose.position are x,
                # y, z, which are world coordinates in
                # `/localization/kinematic_state`. However, applying error to a
                # position in world coordinates is unintuitive and tricky, so
                # we accept the parameters as the entity's local coordinates.
                # local_x, local_y, local_z express that. The simulator
                # calculates the error in the local coordinates. It then
                # transforms the error to the world coordinates, adds the error
                # to the true position (world coordinates), and publishes it as
                # `/localization/kinematic_state`.
                local_x:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                local_y:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                local_z:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
              orientation:
                # The type of geometry_msgs::msg::Pose.orientation is
                # Quaternion, and the actual orientation data members are x, y,
                # z, and w. However, applying error to Quaternions can be
                # unintuitive and tricky, so we accept the parameters as Euler
                # angles here. The simulator internally converts Quaternion to
                # Euler angles and applies the error to them. It then converts
                # the error-applied Euler angles back to Quaternion and
                # publishes them as `/localization/kinematic_state`.
                r:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                p:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                y:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
          twist:
            twist:
              linear:
                x:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                y:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                z:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
              angular:
                x:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                y:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                z:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
      /perception/object_recognition/detection/objects:
        version: 20240605 # architecture_type suffix (mandatory)
        seed: 0 # If 0 is specified, a random seed value will be generated for each run.
        noise:
          model:
            version: 2 # Any of [1, 2].
          v2:
            ellipse_y_radii: [10.0, 20.0, 40.0, 60.0, 80.0, 120.0, 150.0, 180.0, 1000.0]
            distance:
              autocorrelation_coefficient:
                amplitude: 0.32
                decay: 0.45
                offset: 0.26
              mean:
                ellipse_normalized_x_radius: 1.1
                values: [-0.06, -0.04, -0.04, -0.07, -0.26, -0.56, -1.02, -1.05, 0.0]
              standard_deviation:
                ellipse_normalized_x_radius: 1.0
                values: [0.17, 0.20, 0.27, 0.40, 0.67, 0.94, 1.19, 1.17, 0.0]
            yaw:
              autocorrelation_coefficient:
                amplitude: 0.22
                decay: 0.52
                offset: 0.21
              mean:
                ellipse_normalized_x_radius: 1.9
                values: [0.0, 0.01, 0.0, 0.0, 0.0, -0.07, 0.18, 0.06, 0.0]
              standard_deviation:
                ellipse_normalized_x_radius: 0.8
                values: [0.09, 0.15, 0.21, 0.18, 0.17, 0.19, 0.39, 0.15, 0.0]
            yaw_flip:
              autocorrelation_coefficient:
                amplitude: 0.29
                decay: 0.12
                offset: 0.49
              velocity_threshold: 0.1
              rate: 0.12
            true_positive:
              autocorrelation_coefficient:
                amplitude: 0.32
                decay: 0.26
                offset: 0.40
              rate:
                ellipse_normalized_x_radius: 0.7
                values: [0.96, 0.78, 0.57, 0.48, 0.27, 0.07, 0.01, 0.0, 0.0]
