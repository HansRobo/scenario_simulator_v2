simulation:
  AutowareUniverse:
    ros__parameters:
      /localization/kinematic_state:
        version: 20240605 # architecture_type suffix (mandatory)
        seed: 0 # If 0 is specified, a random seed value will be generated for each run.
        nav_msgs::msg::Odometry:
          pose:
            pose:
              position:
                # The data members of geometry_msgs::msg::Pose.position are x,
                # y, z, which are world coordinates in
                # `/localization/kinematic_state`. However, applying error to a
                # position in world coordinates is unintuitive and tricky, so
                # we accept the parameters as the entity's local coordinates.
                # local_x, local_y, local_z express that. The simulator
                # calculates the error in the local coordinates. It then
                # transforms the error to the world coordinates, adds the error
                # to the true position (world coordinates), and publishes it as
                # `/localization/kinematic_state`.
                local_x:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                local_y:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                local_z:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
              orientation:
                # The type of geometry_msgs::msg::Pose.orientation is
                # Quaternion, and the actual orientation data members are x, y,
                # z, and w. However, applying error to Quaternions can be
                # unintuitive and tricky, so we accept the parameters as Euler
                # angles here. The simulator internally converts Quaternion to
                # Euler angles and applies the error to them. It then converts
                # the error-applied Euler angles back to Quaternion and
                # publishes them as `/localization/kinematic_state`.
                r:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                p:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                y:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
          twist:
            twist:
              linear:
                x:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                y:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                z:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
              angular:
                x:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                y:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                z:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
      /perception/object_recognition/detection/objects:
        version: 20240605 # architecture_type suffix (mandatory)
        seed: 0 # If 0 is specified, a random seed value will be generated for each run.
        noise:
          model:
            version: 1 # Any of [0, 1]
          v1:
            correlation_for_delta_t: 0.5
            ellipse_y_radiuses: [10.0, 20.0, 40.0, 60.0, 80.0, 120.0, 150.0, 180.0, 1000.0]
            distance:
              delta_t: 0.5
              ellipse_normalized_x_radius:
                mean: 1.0
                standard_deviation: 1.0
              means: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
              standard_deviations: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
            yaw:
              delta_t: 0.3
              ellipse_normalized_x_radius:
                mean: 1.0
                standard_deviation: 1.0
              means: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
              standard_deviations: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
            yaw_flip:
              delta_t: 0.1
              velocity_threshold: 0.1
              rate_for_stop_objects: 0.0
            mask:
              delta_t: 0.3
              ellipse_normalized_x_radius: 1.0
              rates: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
