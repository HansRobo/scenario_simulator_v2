simulation:
  AutowareUniverse:
    ros__parameters:
      /localization/kinematic_state:
        version: 20240605 # architecture_type suffix (mandatory)
        seed: 0 # If 0 is specified, a random seed value will be generated for each run.
        nav_msgs::msg::Odometry:
          pose:
            pose:
              position:
                # The data members of geometry_msgs::msg::Pose.position are x,
                # y, z, which are world coordinates in
                # `/localization/kinematic_state`. However, applying error to a
                # position in world coordinates is unintuitive and tricky, so
                # we accept the parameters as the entity's local coordinates.
                # local_x, local_y, local_z express that. The simulator
                # calculates the error in the local coordinates. It then
                # transforms the error to the world coordinates, adds the error
                # to the true position (world coordinates), and publishes it as
                # `/localization/kinematic_state`.
                local_x:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                local_y:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                local_z:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
              orientation:
                # The type of geometry_msgs::msg::Pose.orientation is
                # Quaternion, and the actual orientation data members are x, y,
                # z, and w. However, applying error to Quaternions can be
                # unintuitive and tricky, so we accept the parameters as Euler
                # angles here. The simulator internally converts Quaternion to
                # Euler angles and applies the error to them. It then converts
                # the error-applied Euler angles back to Quaternion and
                # publishes them as `/localization/kinematic_state`.
                r:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                p:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                y:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
          twist:
            twist:
              linear:
                x:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                y:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                z:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
              angular:
                x:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                y:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
                z:
                  error:
                    additive:
                      mean: 0.0
                      standard_deviation: 0.0
                    multiplicative:
                      mean: 0.0
                      standard_deviation: 0.0
      /perception/object_recognition/detection/objects:
        version: 20240605 # architecture_type suffix (mandatory)
        seed: 0 # If 0 is specified, a random seed value will be generated for each run.
        noise:
          model:
            version: 2 # Any of [1, 2].
          v2:
            correlation_for_delta_t: 0.5
            ellipse_y_radii: [10.0, 20.0, 40.0, 60.0, 80.0, 120.0, 150.0, 180.0, 1000.0]
            distance:
              delta_t: 0.5
              ellipse_normalized_x_radius:
                mean: 1.8
                standard_deviation: 1.8
              means: [0.25, 0.27, 0.44, 0.67, 1.00, 3.00, 4.09, 3.40, 0.00]
              standard_deviations: [0.35, 0.54, 0.83, 1.14, 1.60, 3.56, 4.31, 3.61, 0.00]
            yaw:
              delta_t: 0.3
              ellipse_normalized_x_radius:
                mean: 0.6
                standard_deviation: 1.6
              means: [0.01, 0.01, 0.00, 0.03, 0.04, 0.00, 0.01, 0.00, 0.00]
              standard_deviations: [0.05, 0.1, 0.15, 0.15, 0.2, 0.2, 0.3, 0.4, 0.5]
            yaw_flip:
              delta_t: 0.1
              velocity_threshold: 0.1
              stop_rate: 0.3
            mask:
              delta_t: 0.3
              ellipse_normalized_x_radius: 0.6
              unmask_rates: [0.92, 0.77, 0.74, 0.66, 0.57, 0.28, 0.09, 0.03, 0.00]
